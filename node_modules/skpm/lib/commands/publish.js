'use strict';

exports.__esModule = true;

let getToken = (() => {
  var _ref = _asyncToGenerator(function* (repo) {
    if (CACHED_TOKEN) {
      return CACHED_TOKEN;
    }
    try {
      const token = yield _auth2.default.getToken();
      yield _github2.default.getRepo(token, repo);
      CACHED_TOKEN = token;
      return token;
    } catch (e) {
      (0, _utils.error)(`The repository doesn't exist or the GitHub token is invalid`);
      throw e;
    }
  });

  return function getToken(_x) {
    return _ref.apply(this, arguments);
  };
})();

var _ora = require('ora');

var _ora2 = _interopRequireDefault(_ora);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _xml2js = require('xml2js');

var _xml2js2 = _interopRequireDefault(_xml2js);

var _opn = require('opn');

var _opn2 = _interopRequireDefault(_opn);

var _inquirer = require('inquirer');

var _exec = require('@skpm/internal-utils/exec');

var _skpmConfig = require('@skpm/internal-utils/skpm-config');

var _skpmConfig2 = _interopRequireDefault(_skpmConfig);

var _extractRepository = require('@skpm/internal-utils/extract-repository');

var _extractRepository2 = _interopRequireDefault(_extractRepository);

var _replaceArraysByLastItem = require('@skpm/internal-utils/replace-arrays-by-last-item');

var _replaceArraysByLastItem2 = _interopRequireDefault(_replaceArraysByLastItem);

var _toolConfig = require('@skpm/internal-utils/tool-config');

var _toolConfig2 = _interopRequireDefault(_toolConfig);

var _auth = require('../utils/auth');

var _auth2 = _interopRequireDefault(_auth);

var _github = require('../utils/github');

var _github2 = _interopRequireDefault(_github);

var _asyncCommand = require('../utils/async-command');

var _asyncCommand2 = _interopRequireDefault(_asyncCommand);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const EMPTY_APPCAST = {
  rss: {
    $: {
      'xmlns:sparkle': 'http://www.andymatuschak.org/xml-namespaces/sparkle',
      'xmlns:dc': 'http://purl.org/dc/elements/1.1/',
      version: '2.0'
    },
    channel: [{ item: [] }]
  }
};

let CACHED_TOKEN;
exports.default = (0, _asyncCommand2.default)({
  command: 'publish <bump>',

  desc: 'Publish a new version of the plugin. <bump> can be the new version number or any of the following: major, minor, patch, premajor preminor, prepatch, prerelease.',

  builder: {
    'repo-url': {
      description: 'Specify the repository URL (default to the one specified in package.json).',
      type: 'string'
    },
    'skip-release': {
      description: 'Do not create a release on GitHub.com.',
      type: 'boolean',
      // conflicts: 'open-release', // TODO un-comment when https://github.com/yargs/yargs/issues/929 is fixed
      implies: 'download-url'
    },
    'open-release': {
      description: 'Open the newly created release on GitHub.com.',
      type: 'boolean',
      alias: 'o'
    },
    'skip-registry': {
      description: 'Do not publish to the plugins registry if not already present.',
      type: 'boolean'
    },
    'download-url': {
      description: "Specify the new version's download URL (default to the asset of the release created on GitHub.com).",
      type: 'string'
    },
    appcast: {
      description: 'Specify the local path to the appcast (default to .appcast.xml). If `false`, then the appcast update will be skipped',
      type: 'string'
    }
  },

  handler(argv) {
    return _asyncToGenerator(function* () {
      (0, _replaceArraysByLastItem2.default)(argv, ['repoUrl', 'skipRelease', 'openRelease', 'skipRegistry', 'downloadUrl', 'appcast']);

      let packageJSON;
      try {
        packageJSON = require(_path2.default.join(process.cwd(), 'package.json'));
      } catch (err) {
        (0, _utils.error)(`Error while reading the package.json file`);
        throw err;
      }

      const skpmConfig = (0, _skpmConfig2.default)(packageJSON);

      const repo = argv.repoUrl && (0, _extractRepository2.default)(argv.repoUrl) || skpmConfig.repository;

      if (!repo) {
        throw new Error('Please supply github.com repo URL as --repo-url or in "repository" field in the package.json.');
      }

      if (!argv.skipRegistry && !skpmConfig.description) {
        const manifest = _path2.default.join(process.cwd(), skpmConfig.manifest);
        let manifestJSON;
        try {
          manifestJSON = require(manifest);
        } catch (err) {
          // ignore
        }
        if (!manifestJSON || !manifestJSON.description) {
          throw new Error('Missing "description" field in the package.json.');
        }
      }

      let token;

      if (!argv.skipRelease || !argv.skipRegistry) {
        token = yield getToken(repo);
      }

      let tag = skpmConfig.version;

      let spinner = null;

      function print(text, action) {
        if (process.env.CI) {
          console.log(text);
        } else if (spinner) {
          if (action) {
            spinner[action](text);
          } else {
            spinner.text = text;
            if (!spinner.isSpinning) {
              spinner.start();
            }
          }
        } else {
          spinner = new _ora2.default({
            text,
            color: 'magenta'
          }).start();
        }
      }

      print(`Checking if \`${repo}\` is accessible`);

      if (argv.bump) {
        print('Bumping package.json version and creating git tag');
        const { stdout } = yield (0, _exec.exec)(`npm version ${argv.bump} -m "Publish %s release :rocket:" --allow-same-version`);
        tag = stdout.trim();
      }

      if (argv.appcast !== 'false') {
        print('Updating the appcast file');

        const appcast = _path2.default.join(process.cwd(), (argv.appcast || skpmConfig.appcast || '.appcast.xml').replace(/^\.\//g, ''));
        const appcastObj = yield new Promise(function (resolve) {
          _fs2.default.readFile(appcast, function (err, data) {
            if (err) {
              return resolve(EMPTY_APPCAST);
            }
            return _xml2js2.default.parseString(data, function (parseErr, result) {
              if (parseErr) {
                return resolve(EMPTY_APPCAST);
              }
              return resolve(result);
            });
          });
        });

        appcastObj.rss.channel[0].item.unshift({
          enclosure: [{
            $: {
              url: argv.downloadUrl || `https://github.com/${repo}/releases/download/${tag}/${_path2.default.basename(skpmConfig.main).replace(/ /g, '.')}.zip`,
              'sparkle:version': tag.replace('v', '')
            }
          }]
        });
        const builder = new _xml2js2.default.Builder();
        const xml = yield builder.buildObject(appcastObj);

        _fs2.default.writeFileSync(appcast, xml);

        yield (0, _exec.exec)(`git add "${appcast}"`);
        yield (0, _exec.exec)('git commit -m "Update .appcast with new tag :sparkles:"');
      }

      print('Pushing the changes to Github');

      yield (0, _exec.exec)(`git push origin HEAD`);

      if (argv.bump) {
        yield (0, _exec.exec)(`git push -f origin HEAD ${tag}`);
      }

      if (!argv.skipRelease) {
        let script = (packageJSON.scripts || {}).prepublish && 'prepublish';
        if (!script) {
          script = (packageJSON.scripts || {}).prepare && 'prepare';
        }
        if (!script) {
          script = (packageJSON.scripts || {}).build && 'build';
        }

        if (script) {
          print('Building the plugin');
          yield (0, _exec.exec)(`NODE_ENV=production npm run ${script}`);
        }

        print('Zipping the plugin');
        const tempZip = `${Date.now()}.zip`;
        yield (0, _exec.exec)(`zip --symlinks -r ${tempZip} '${skpmConfig.main}' -x '*.DS_Store'`, {
          maxBuffer: 2000 * 1024
        });

        // eslint-disable-next-line prefer-const
        let { notarisation, notarization } = _toolConfig2.default.get();
        if (!notarization) {
          // suport both spelling
          notarization = notarisation;
        }
        if (notarization) {
          if (notarization.command) {
            print('Running custom notarization command');
            yield (0, _exec.exec)(`${notarization.command} ${tempZip}`);
          } else {
            print('Preparing the plugin to be notarized');
            yield (0, _exec.exec)(`codesign -f -s "${notarization.authority}" --timestamp --identifier "${skpmConfig.identifer}" ${tempZip}`);

            print('Sending the plugin to be notarized');
            let requestId;
            try {
              const { stderr } = yield (0, _exec.exec)(`xcrun altool --notarize-app -f ${tempZip} --primary-bundle-id "${skpmConfig.identifer}" -u "${notarization.username}" -p "${notarization.password}"`);[requestId] = stderr.split('RequestUUID = ')[1].split('\n');
            } catch (err) {
              if (err.message.indexOf('already been uploaded') !== -1) {
                // we can handle that
                ;[requestId] = err.message.split('The upload ID is ')[1].split('"');
              } else {
                throw err;
              }
            }

            console.log(`\n\nPlugin sent to the notarization server. To check the status of the request (which might take a few minutes), run:\nxcrun altool --notarization-info ${requestId.trim()} -u "${notarization.username}" -p "${notarization.password}"\n\n`);
          }
        } else {
          console.warn(`\n\n⚠️ The plugin won't be notarized because the configuration is missing. It is a requirement if the plugin contains a native obj-c framework on macOS 10.15 and might become one for later version of macOS.\nFor more information about how to set up the notarization process and what it means, check https://github.com/skpm/skpm/blob/master/docs/notarization.md.\n\n`);
        }

        print('Creating a draft release on GitHub');
        const { id: releaseId } = yield _github2.default.createDraftRelease(token, repo, tag);

        print('Uploading zip asset');
        yield _github2.default.updateAsset(token, repo, releaseId, tempZip, `${_path2.default.basename(skpmConfig.main)}.zip`);

        print('Publishing the release');
        yield _github2.default.publishRelease(token, repo, releaseId);

        print('Removing the temporary zip');
        yield (0, _exec.exec)(`rm -f ${tempZip}`);
      }

      if (!argv.skipRegistry && (!packageJSON.skpm || !packageJSON.skpm.private)) {
        print('Checking if the plugin is on the official plugin directory');
        const upstreamPluginJSON = yield _github2.default.getRegistryRepo(token, skpmConfig, repo);
        if (!upstreamPluginJSON.existingPlugin) {
          if (spinner) spinner.stop();
          const { addToRegistry } = yield (0, _inquirer.prompt)({
            type: 'confirm',
            name: 'addToRegistry',
            message: `The plugin is not on the plugins registry yet. Do you wish to add it?`,
            default: true
          });
          if (addToRegistry) {
            print('Publishing the plugin on the official plugin directory');
            yield _github2.default.addPluginToPluginsRegistryRepo(token, skpmConfig, repo, upstreamPluginJSON);
          }
        }
      }

      print('Plugin published!', 'succeed');
      console.log(`${skpmConfig.name}@${tag.replace('v', '')}`);

      if (argv.openRelease) {
        (0, _opn2.default)(`https://github.com/${repo}/tag/${tag.replace('v', '')}`);
      }
    })();
  }
});