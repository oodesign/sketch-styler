'use strict';

exports.__esModule = true;

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _exec = require('@skpm/internal-utils/exec');

var _replaceArraysByLastItem = require('@skpm/internal-utils/replace-arrays-by-last-item');

var _replaceArraysByLastItem2 = _interopRequireDefault(_replaceArraysByLastItem);

var _asyncCommand = require('../utils/async-command');

var _asyncCommand2 = _interopRequireDefault(_asyncCommand);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const homedir = require('os').homedir();

const logLocations = [`${homedir}/Library/Logs/com.bohemiancoding.sketch3/Plugin Output.log`, `${homedir}/Library/Logs/com.bohemiancoding.sketch3/Plugin Log.log`, `${homedir}/Library/Logs/com.bohemiancoding.sketch3.xcode/Plugin Log.log`, `${homedir}/Library/Logs/com.bohemiancoding.sketch3.beta/Plugin Log.log`, `${homedir}/Library/Logs/com.bohemiancoding.sketch3.private/Plugin Log.log`];

exports.default = (0, _asyncCommand2.default)({
  command: 'log',

  desc: 'Show the Sketch plugins logs.',

  builder: {
    f: {
      description: 'The `-f` option causes tail to not stop when end of file is reached, but rather to wait for additional data to be appended to the input.',
      type: 'boolean',
      alias: 'F',
      default: 'false'
    },
    number: {
      description: 'Shows `number` lines of the logs.',
      type: 'number',
      alias: 'n'
    }
  },

  handler(argv, done) {
    (0, _replaceArraysByLastItem2.default)(argv, ['f', 'number']);

    const args = [];

    if (argv.f) {
      args.push('-F');
    } else if (argv.number !== undefined) {
      args.push(`-n ${argv.number}`);
    }

    const childProcesses = [];

    function killAll() {
      childProcesses.forEach(child => {
        if (!child.killed) {
          child.kill();
        }
      });
    }

    const count = logLocations.reduce((prev, logsLocation) => {
      prev[logsLocation] = 1;
      return prev;
    }, {});
    function checkEnd(logsLocation) {
      count[logsLocation] -= 1;
      if (Object.keys(count).every(k => count[k] <= 0)) {
        killAll();
        done();
      }
    }

    function listenToLogs(logsLocation) {
      const child = _child_process2.default.spawn('tail', [...args, logsLocation], {
        cwd: process.cwd()
      });

      if (child.stdout) {
        child.stdout.on('data', data => {
          console.log(String(data).replace(/ «Plugin Output»/g, '').replace(/\n$/g, ''));
        });
      }

      if (child.stderr) {
        child.stderr.on('data', data => {
          const dataString = String(data);
          if (dataString.indexOf('No such file or directory')) {
            count[logsLocation] += 1;
            // touch the file so that we can listen to it
            return (0, _exec.exec)(`touch "${logsLocation}"`)
            // restart the listening for this log
            .then(() => listenToLogs(logsLocation)).catch(err => {
              // if we can't create the file it means that the variant is not present
              if (err.message.indexOf('No such file or directory')) {
                checkEnd(logsLocation);
                return;
              }
              (0, _utils.error)('while reading the logs');
              done(err);
            });
          }
          return console.error(String(data));
        });
      }

      child.on('exit', () => {
        checkEnd(logsLocation);
      });

      child.on('error', err => {
        (0, _utils.error)('while reading the logs');
        killAll();
        done(err);
      });

      childProcesses.push(child);
    }

    logLocations.forEach(listenToLogs);

    if (!childProcesses.length) {
      done();
    }
  }
});