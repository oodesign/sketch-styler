'use strict';

exports.__esModule = true;

var _ora = require('ora');

var _ora2 = _interopRequireDefault(_ora);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _gittar = require('gittar');

var _gittar2 = _interopRequireDefault(_gittar);

var _fs = require('fs.promised');

var _fs2 = _interopRequireDefault(_fs);

var _chalk = require('chalk');

var _path = require('path');

var _inquirer = require('inquirer');

var _jszip = require('jszip');

var _jszip2 = _interopRequireDefault(_jszip);

var _checkDevMode = require('@skpm/internal-utils/check-dev-mode');

var _checkDevMode2 = _interopRequireDefault(_checkDevMode);

var _replaceArraysByLastItem = require('@skpm/internal-utils/replace-arrays-by-last-item');

var _replaceArraysByLastItem2 = _interopRequireDefault(_replaceArraysByLastItem);

var _asyncCommand = require('../utils/async-command');

var _asyncCommand2 = _interopRequireDefault(_asyncCommand);

var _getGitUser = require('../utils/get-git-user');

var _getGitUser2 = _interopRequireDefault(_getGitUser);

var _utils = require('../utils');

var _setup = require('../utils/setup');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const TEMPLATE = 'skpm/skpm';
const RGX = /\.(woff2?|ttf|eot|jpe?g|ico|png|gif|mp4|mov|ogg|webm)(\?.*)?$/i;
const isMedia = str => RGX.test(str);

function buildStubs(argv) {
  const stubs = new Map();['name', 'slug'].forEach(str => {
    // if value is defined
    if (argv[str] !== undefined) {
      stubs.set(new RegExp(`{{\\s?${str}\\s}}`, 'g'), argv[str]);
    }
  });
  return stubs;
}

function replaceStubs(stubs, string) {
  let result = string;
  stubs.forEach((v, k) => {
    result = result.replace(k, v);
  });
  return result;
}

exports.default = (0, _asyncCommand2.default)({
  command: 'create <dest>',

  desc: 'Create a new Sketch plugin.',

  builder: {
    cwd: {
      description: 'A directory to use instead of $PWD.',
      type: 'string',
      default: '.'
    },
    name: {
      description: "The plugin's name",
      type: 'string'
    },
    template: {
      description: 'The repository hosting the template to start from',
      type: 'string',
      default: 'skpm/skpm'
    },
    force: {
      description: 'Force option to create the directory for the new app',
      type: 'boolean',
      default: false
    },
    git: {
      description: 'Initialize version control using git',
      type: 'boolean',
      default: true
    },
    install: {
      description: 'Install dependencies',
      type: 'boolean',
      default: true
    }
  },

  handler(argv) {
    return _asyncToGenerator(function* () {
      (0, _replaceArraysByLastItem2.default)(argv, ['cwd', 'name', 'template', 'force', 'git', 'install']);

      // Prompt if incomplete data
      if (!argv.dest) {
        (0, _utils.warn)('Insufficient command arguments! Prompting...');
        (0, _utils.info)('Alternatively, run `skpm create --help` for usage info.');

        const questions = (0, _setup.isMissing)(argv);
        const response = yield (0, _inquirer.prompt)(questions);
        Object.assign(argv, response);
      }

      if (!argv.name) {
        argv.name = argv.dest; // eslint-disable-line
      }

      if (!argv.name) {
        return (0, _utils.error)('Need to specify a destination', 1);
      }

      argv.slug = argv.name.toLowerCase().replace(/\s+/g, '-'); // eslint-disable-line

      const cwd = (0, _path.resolve)(argv.cwd);
      const target = argv.dest && (0, _path.resolve)(cwd, argv.dest);
      const exists = target && (0, _utils.isDir)(target);

      if (exists && !argv.force) {
        return (0, _utils.error)('Refusing to overwrite current directory! Please specify a different destination or use the `--force` flag', 1);
      }

      if (exists && argv.force) {
        const { enableForce } = yield (0, _inquirer.prompt)({
          type: 'confirm',
          name: 'enableForce',
          message: `You are using '--force'. Do you wish to continue?`,
          default: false
        });

        if (enableForce) {
          (0, _utils.info)('Initializing project in the current directory!');
        } else {
          return (0, _utils.error)('Refusing to overwrite current directory!', 1);
        }
      }

      const repo = argv.template || TEMPLATE;

      const spinner = (0, _ora2.default)({
        text: 'Fetching the template',
        color: 'magenta'
      }).start();

      function print(text) {
        if (process.env.CI) {
          console.log(text);
        } else {
          spinner.text = text;
        }
      }

      print('Fetching the template');

      // Attempt to fetch the `template`
      const archive = yield _gittar2.default.fetch(repo).catch(function (err) {
        spinner.fail('An error occured while fetching template.');
        return (0, _utils.error)((err || {}).code === 404 ? `Could not find repository: ${repo}` : (err || {}).message, 1);
      });

      print('Extracting the template');

      // Extract files from `archive` to `target`
      const keeps = [];
      yield _gittar2.default.extract(archive, target, {
        strip: 2,
        filter(path, obj) {
          if (path.includes('/template/')) {
            obj.on('end', () => {
              if (obj.type === 'File' && !isMedia(obj.path)) {
                keeps.push(obj.absolute);
              }
            });
            return true;
          }
          return false;
        }
      });

      if (!keeps.length) {
        return (0, _utils.error)(`No \`template\` directory found within ${repo}!`, 1);
      }
      const stubs = buildStubs(argv);

      // Update each file's contents
      const enc = 'utf8';
      // eslint-disable-next-line no-restricted-syntax
      for (const entry of keeps) {
        if ((0, _path.extname)(entry) === '.sketch') {
          const data = yield _fs2.default.readFile(entry);
          const zip = yield _jszip2.default.loadAsync(data);
          const promises = [];
          // replace in all the pages
          zip.folder('pages').forEach(function (relativePath) {
            promises.push(_asyncToGenerator(function* () {
              const pagePath = `pages/${relativePath}`;
              let buf = yield zip.file(pagePath).async('string');
              buf = replaceStubs(stubs, buf);
              zip.file(pagePath, buf);
            }));
          });
          yield Promise.all(promises.map(function (x) {
            return x();
          }));
          yield new Promise(function (resolvePromise, reject) {
            zip.generateNodeStream({ type: 'nodebuffer', streamFiles: true }).pipe(_fs2.default.createWriteStream(entry)).on('finish', function () {
              // JSZip generates a readable stream with a "end" event,
              // but is piped here in a writable stream which emits a "finish" event.
              resolvePromise();
            }).on('error', reject);
          });
        } else {
          let buf = yield _fs2.default.readFile(entry, enc);
          buf = replaceStubs(stubs, buf);
          yield _fs2.default.writeFile(entry, buf, enc);
        }
      }

      print('Parsing `package.json` file');

      // Validate user's `package.json` file
      let pkgData;
      const pkgFile = (0, _path.resolve)(target, 'package.json');

      if (pkgFile) {
        pkgData = JSON.parse((yield _fs2.default.readFile(pkgFile)));
      } else {
        (0, _utils.warn)('Could not locate `package.json` file!');
      }

      if (pkgData && !pkgData.author) {
        const gitUser = yield (0, _getGitUser2.default)();
        if (gitUser && gitUser.username && gitUser.email) {
          pkgData.author = `${gitUser.username.trim()} <${gitUser.email.trim()}>`;
        }
      }

      // Update `package.json` key
      if (pkgData) {
        print('Updating `name` within `package.json` file');
        pkgData.name = argv.slug;
        if (!pkgData.skpm) {
          pkgData.skpm = {};
        }
        pkgData.skpm.name = argv.name;
        if (!pkgData.skpm.main || pkgData.skpm.main === 'plugin.sketchplugin') {
          pkgData.skpm.main = `${argv.slug}.sketchplugin`;
        }
      }
      // Find a `manifest.json`; use the first match, if any
      const files = yield (0, _globby2.default)(`${target}/**/manifest.json`);
      const manifest = files[0] && JSON.parse((yield _fs2.default.readFile(files[0])));
      if (manifest && manifest.menu) {
        print('Updating `title` within `manifest.json` file');
        manifest.menu.title = argv.name;
        // Write changes to `manifest.json`
        yield _fs2.default.writeFile(files[0], JSON.stringify(manifest, null, 2));
      }

      if (pkgData) {
        // Assume changes were made ¯\_(ツ)_/¯
        yield _fs2.default.writeFile(pkgFile, JSON.stringify(pkgData, null, 2));
      }

      let shouldAskForDevMode = false;

      if (argv.install) {
        print('Installing dependencies');
        shouldAskForDevMode = yield (0, _setup.install)(target, spinner);
      }

      spinner.succeed('Done!\n');

      if (!process.env.CI && shouldAskForDevMode) {
        yield (0, _checkDevMode2.default)();
      }

      if (argv.git) {
        yield (0, _setup.initGit)(target);
      }

      return `${`
To get started, cd into the new directory:
  ${(0, _chalk.green)(`cd ${argv.dest}`)}

To start a development live-reload build:
  ${(0, _chalk.green)(`npm run start`)}

To build the plugin:
  ${(0, _chalk.green)(`npm run build`)}

To publish the plugin:
  ${(0, _chalk.green)('skpm publish')}
`}\n`;
    })();
  }
});